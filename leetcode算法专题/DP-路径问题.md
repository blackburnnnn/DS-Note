1. 

2. (11/3)62.不同路径

   - 第一种通用dp解决方法：**经验解法**

   - 需要思考dp求解的五个核心问题

     1. 如何确定可以使用动态规划来求解问题(**为什么要用dp**)
     2. 如何确定本题的**状态定义**
     3. 如何确定**状态转移方程**
     4. 对**状态转移的要求**是什么
     5. 如何分析动态规划的**时间复杂度**

   - 核心思想

     <img src="/Users/leizhenhao/Library/Application Support/typora-user-images/image-20221104100110997.png" alt="image-20221104100110997" style="zoom:80%;" />

   - **python构建m行n列二维矩阵**

     - 其他需要先声明再赋值，python可以同时进行，所以代码量更少
     - `f = [[1] * n] + [[1] + [0] * (n - 1) for _ in range(m - 1)]`，**注意`range(1)`只会访问到0！**
     - 如`[[1, 1], [1, 0], [1, 0]]`，内部有多少`[]`就是多少行，内部的`[]`有多少元素就是多少列
     - `a = [1 * 3]` $\Rightarrow$ `[3]`
     - `a = [1] * 3` $\Rightarrow$ `[1,1,1]`
     - `a = [[1] * 3]` $\Rightarrow$ `[[1],[1],[1]]`
     - `b =[[0] * 3 for _ in range(2)]` $\Rightarrow$ `[[0, 0, 0], [0, 0, 0]]`：`[0]*3`是一个整体，**后面是将这个整体循环2次，相当于一个语法糖，用于确定二维列表的行数**
     - `b =[[1] + [0] * 3 for _ in range(2)]` $\Rightarrow$ `[[1, 0, 0, 0], [1, 0, 0, 0]]`：**这时候`[1] + [0] * 3`是一个整体！**要注意同类型变量才能进行数值运算
     - 最后补一行全1向量：`f = [[1] * n] + [[1] + [0] * (n - 1)] * (m - 1)`，注意左边加的要有两个中括号，和加号右边的类型保持一致！若不一致，pycharm也会有高亮warning

   - 自己发明的创建方式，**后面接一个for循环和直接乘效果是一样的**

     ```python
     m, n = 3, 4
     f1 = [[0] * (n - 1) for _ in range(m - 1)]
     f2 = [[0] * (n - 1)] * (m - 1)
     f1 == f2 => True