

### 进度记录

> 11/10

- 基于W2&W3(栈&队列应用/链表/C++基础)内容进行复习
- 与王道所学内容进行对照复习

> 11/11

- 完成W3(栈&队列应用/链表/C++基础)&W4(递归、DFS、BFS)
- 与王道所学内容进行对照复习

> 11/12

- W3(栈&队列应用/链表/C++基础)
- 与王道所学内容进行对照复习
- **把W5(C++进阶部分，构造函数、析构函数等)学习完毕，然后重新打一遍之前的虚幻链表代码**，现在先把教材的链表代码理解了，理论过一遍
- 递归直接敲代码

> 11/15

​	$\star\star\star$

- **因为链表代码教材与王道差别比较大，且教材和王道对应的知识点之前都掌握了，所以先把主题理论过了，代码细节今天就不看了，到时候开了会再考虑看不看，性价比很高。**
- W5递归代码重写斐波那契数列、汉诺塔、八皇后，理解DFS、BFS，也暂时不需要花太多时间，到时候知道代码考什么再说

> 11/18 2h

- DFS、BFS、八皇后问题：原理已经理解了，还需要复习**具体用C++二维数组进行递归的过程**
- W5 C++进阶理论 

> 11/21

现在完全基于范围来复习了，所以很多课件也没必要再看

------

专业课题型：

- 与数据结构本身内容相关
- 利用数据结构知识设计一个O(nlogn)的算法

注意事项：

- 代码写伪代码即可
- 允许增加函数或者改变函数接口
- 树是重点

### C++理论

#### 基本语法

1. switch语句

   ```C++
   switch(expression){//此处写变量
       case constant-expression://此处可能出现的具体变量值
          statement(s);
          break; //如果 case 语句不包含 break，控制流将会 继续 后续的 case，直到遇到 break 为止。
       //可以有任意数量的 case 语句
       case constant-expression:
          statement(s);
          break; 
      //一个 switch语句可以有一个可选的default case,在switch的结尾。default case可用于在上面所有case都不为真时执行一个任务。default case中的break语句不是必需的,毕竟后面也没有代码了    
       default : 
          statement(s);
   }		
   ```

2. do-while循环(不常用)

   ```C++
   do//do后面接大括号
   {
      statement(s);
   }while( condition );//特别注意while部分写完后还需要加上一个分号！
   ```

3. 枚举类型

4. C++ const(比C const的功能多很多)

#### 指针&引用

1. 指针传递

   ```C++
   int bypointer(int*);
   //函数必须在主函数前声明，但是可以接着具体定义，也可以在主函数后面定义；
   //如果不接着具体定义，注意打上分号    
   
   int main()
   {
       int number = 5;
       int* numptr = &number;//取地址、'int*'表明整型指针类型
       cout << bypointer(numptr);
   }
   
   int bypointer(int* intptr)//形参是一个指针(即地址)
   {
       //*是基于该地址获取其对应的值
       *intptr = (*intptr)*(*intptr)
       return (*intptr);
   }
   ```

2. 引用传递(引用更加强大，直接指代了原对象，不需要再用*号)

   且引用可以节省空间，如果用普通参数传递每次调用时都会为参数分配栈空间

   ```C
   int byref(int&);
   ...
       cout << byref(number);
   int byref(int& n)
   {
       n = n*n*n;
       return n;
   }
   ```

3. **引用传递和指针传递的区别**

   - 指针是一个变量，这个变量存储的是一个地址，指向内存的一个存储单元

   - 引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名

     所以声明一个引用变量` 	int& c = a`,那么这个变量c就和a完全是一个东西了，只是换了个“马甲”，所以比指针更加严苛。

#### 类模板&类语法补充

1. 函数重载：如果参数列表不同，则允许函数名相同

2. 模板意义理解：对于操作相同或类似的函数，如果希望可以改变输入数据的类型，而不重写大量代码，则可以将整体框架使用模板，从而使同一套操作适用于任何数据类型。

3. 实例

   ```C++
   #include ...
   
   //实际上声明一个类和类中函数的具体代码可以放在一个文件中
   //在声明类时，需要有template <class T>，表明使用模板类，且占位符为T
   //之后在初始化一个模板类的对象时，声明这个对象的类型，则将基于此类型构建这个成员
   template <class T>              
   class Stack { 
     private: 
       //如果不适用模板类
       vector<T> elems;     // 元素 
    
     public: 
       void push(T const&);  // 入栈
       void pop();               // 出栈
       T top() const;            // 返回栈顶元素
       bool empty() const{       // 如果为空则返回真。
           return elems.empty(); 
       } 
   }; 
   
   //同样，如果使用了模板类，在写类中具体函数的代码时，也需要注明template <class T>
   template <class T>
   //如果没有模板类，下面这一行应为:void Stack::push(...)    
   void Stack<T>::push (T const& elem) 
   { 
       // 追加传入元素的副本
       elems.push_back(elem);    
   } 
    
   int main() 
   { 
       Stack<int> intStack;// int 类型的栈 
       Stack<string> stringStack;// string 类型的栈 
       // 操作int 类型的栈 
       intStack.push(7); 
       cout << intStack.top() <<endl; 
    
       // 操作string 类型的栈 
       stringStack.push("hello"); 
       cout << stringStack.top() << std::endl; 
       stringStack.pop(); 
   }
   ```

4. 注意如果使用了类模板，且分开.h和.cpp，那么**在主函数中就需要#include ".cpp"了(暂时不明白原因)**

#### 面向对象基础

1. 类的声明：

   - 包括成员变量、成员函数

   - 放在.h文件里

2. 成员函数的定义

   - 放在.cpp文件中

   - 注意包含1中声明类的头文件

   - 具体定义成员函数时注意语法：

     **函数返回类型 类名::函数名(参数列表){}**

     ```C++
     void BinaryTree::Print(TreeNode *aroot){
         if(aroot!=NULL){
             Print(aroot->left);
             Print(aroot->right);
             cout<<aroot->value<<" ";
         }
     }
     ```

3. **总体基本架构**

   - leizhenhao.h：不需要引入任何文件，只需声明项目所需的变量和函数 

     ```C++
     const int maxqueue = 10;
     class Queue {
     成员函数:
     	Queue( );//构造函数
     	bool empty( ) const;
     	Error code serve( );
     	Error code append(const Queue entry &item);
     	Error code retrieve(Queue entry &item) const;
     成员数据:
     	int count;
     	int front, rear;
     	Queue entry entry[maxqueue];
     };
     ```

   - leizhenhao.cpp：需要引入对应的.h，然后对该.h中的变量和函数进行具体定义

   - main.cpp：
     - 相当于是一个展示窗口，因为上面的.h和.cpp已经共同构建好了诸多接口，所以在这个main.cpp中只需要使用这些接口来实现具体功能即可

     - **注意若要使用某函数，只需引入其所在的.h文件，而不需要引入其对应的.cpp文件** 11/5

       **且引入.h时加双引号而不能是尖括号\#include “leizhenhao.h”**

     - 声明类成员：类名 成员名
     - 访问成员变量/使用成员函数：成员名.xxx

4. **public private关键词**

   1. class在.h中定义，其中有共有变量/函数(public)，以及私有变量/函数(private)。

      如果现在在main.cpp中声明了一个类，其中的private成员是不可以被外部直接访问(比如cout)或修改的，**但是能被该类的所有成员函数访问和修改**。

5. **构造函数**

   语法：
   class名::class名(){	}

   通常是用构造函数初始化private变量

   ```C++
   MyStack::MyStack()
   {
      count = 0;
   }
   ```

### W1 数据结构概念

#### 概要	

1. C++基本操作
2. 类和对象基本概念
3. 类的成员变量和成员函数
4. C++中private和public关键字	

#### 理论内容

1. 结构化数据：简言之就是数据库数据；其他数据则为非结构化数据
2. 数据结构三要素：
   - 逻辑结构：元素的相互关系
     - 线性结构
     - 非线性结构
   - 存储结构(即物理结构)：关系的具体表示方式
     - 顺序存储
     - 链式存储
     - 索引存储
     - 散列存储
   - 数据操作与运算：基于存储结构，算法的具体实现
3. 抽象数据类型(ADT):
   - 定义了一个数据的**逻辑结构**以及在此结构上的一组**算法**。
   - 数据更具体，比如可以将一类数据定义为学生(即将学生数据抽象为一个整体)
4. 算法：
   - 概念在计算机逻辑上实现的解决某一问题的**一套操作**
   - 五个特性

### W2 栈和队列

王道代码是基于结构体，学校代码是基于类。

#### 栈

**概念与实现**

- 相关变量

  1.栈内元素个数count/2.表示栈的静态数组

- 相关函数

  1.创建栈(类声明&构造函数)/2.判空/3.元素入栈/4.元素出栈/5.访问栈顶元素

- 实现时需注意的关键点

  - 用count记录栈中元素个数，初始化时令count=0，且后续代码均根据count值判空、判满。
  - 王道代码中用变量top作为栈顶指针，**这里的count既用来访问栈顶元素，即`entry[count-1]`，又是栈内元素个数的计数器。**

- .h

  注意此处的**带const的函数**和**const引用传值**

  ```C++
  enum Error_code{underflow, overflow, success};//枚举类型
  const int maxstack = 10;//const锁定
  
  class MyStack {
  public:
     MyStack();//1.构造函数
     bool empty() const;//2.判空操作
     //在类成员函数的声明和定义中；后面接有const的函数不能对该类中的变量进行修改操作；且const的对象，不能引用非const的成员函数
     Error_code push(const int &item);//3.压入元素
     //对于复制类类型或大型数组，非引用形参效率太低。所以此时需要将形参定义为引用类型。但如果只是为了避免复制，而不修改实参，那么就应该把形参定义为const引用。这样既提高了传值效率，也避免实参被修改。
     Error_code pop();//4.弹出元素
     Error_code top(int &item) const;//5.访问栈顶元素
  
  private:
     int count;//6.栈内元素个数
     int entry[maxstack];//7.表示该栈的静态数组
  };
  ```

**栈的代码应用题**

1. 对一个数组进行逆序(容易)

#### 队列

**概念与实现**

- 基本性质：**队列中的元素只能从队尾插入(入队)，从队首删除(出队)**。

- 基本操作：

  1.创建队列(类声明&构造函数)/2.入队/3.出队/4.访问队首元素/5.判断队列空

- 实现时需注意的关键点(基于教材代码)

  1. 三个变量:

     count记录队列元素个数，初始值为0；

     front为队头指针，初始值为0；

     rear为队尾指针，初始值为-1。

  2. 判空 `return count==0`

  3. 入队：判断队满 `if(rear >= maxqueue-1)`

  4. 出队：判断队空 ` if(count <= 0)`

  5. 获取队首元素

  6. 获取队列长度
  
  7. 清空队列
  
  8. 出队并获取该元素

**队列的代码应用题**

1. 用两个栈实现队列，请实现两个函数appendTail和deleteHead，完成在队列尾部插入结点和在队列首部删除结点的功能。
2. 用两个队列实现栈?

#### 循环队列

- 实现时需注意的关键点(基于教材代码)

  1. 三个变量:

     count记录队列元素个数，初始值为0；

     front为队头指针，初始值为0；

     **rear为队尾指针，初始值为maxqueue-1，maxqueue为队列最大长度**

  2. 容易理解的是，**不能根据front和rear的差值来判断队列空或满，而应根据count值来判定队列空或满**。

  3. 元素入队，rear++

     **此时还需处理队尾下标，若队列未满，但rear已达到maxqueue-1，则应将rear修正到数组头部(这也是循环队列的意义所在)；**

     **` rear = ((rear + 1)==maxqueue) ? 0 : (rear + 1);//因为每次只插入一个元素，所以只考虑增量为1即可。所以若rear正好处于数组尾部，那么接下来的一次插入会直接将队尾重置至0位置，否则rear正常累加 `**

  4. 元素出队，front++

     同样此时还需以同样的思路处理front指针

     **`front = ((front + 1)==maxqueue) ? 0 : (front + 1);`**

### W3 链表&栈的应用

#### 数制转换

1. C++实际代码中使用栈：调用标准模板库(stl)，即`#include <stack>`

2. 将十进制数n转换为r进制数 核心逻辑

   ```C++
   while(n){
       numbers.push(n%r);//将n模r依次压入栈中
       n=n/r;//用n整除r代替n，循环
     }
   while (!numbers.empty()) {
       cout << numbers.top() << " ";     
       numbers.pop();
     }
   ```

3. 如何将n进制数转化为10进制数(易)

#### 迷宫问题

算法：

- step1 将当前位置入栈；
- step2 按下、右、上、左顺序判断下一步是否可通，若可通，重复步骤1；否则换方向继续搜索；
- step3 如若四个方向均无通路，则将当前位置出栈，从下一方向继续搜索，直至到达终点或无法到达终点。若能到达，则栈中的坐标即为从起点到终点的路径。

#### 表达式求值

此内容可充分利用《王道》

> 参考 https://www.cnblogs.com/zzliu/p/10801113.html

1. 前缀、中缀、后缀表达式基本概念

   - 中缀表达式就是日常使用的计算方式，但计算机不能像人脑一样处理，其内部都是先将中缀表达式转化为前缀or后缀表达式再计算。
   - 均由操作数、运算符、界限符组成

2. **中缀转后缀的手算实现**(v09 00:09:21)

   - 最重要的是先基于中缀表达式确定各部分计算顺序，使用**左优先原则：只要中缀表达式左边的运算符能先运算，就优先将左边的部分转化为后缀表达式。**
   - **后缀表达式的最终形式当然不是所有操作符都在所有操作数后面**！确定计算顺序，按左优先原则正常计算即可。

3. 利用栈实现表达式计算

   中缀、后缀的转换以及具体计算，都是通过栈

   - 第一步：**利用栈将中缀表达式转换为后缀表达式**(v10 00:01:02)

     **初始化一个栈来处理操作符和界限符**。从左到右依次扫描各个元素，直至末尾，可能遇到的三种情况&对应处理方式：

     1. 遇到**操作数**：直接加入后缀表达式

     2. 遇到**界限符**(左括号or右括号)：**遇到'('直接入栈**；**遇到')'则依次弹出栈内运算符直到弹出'('**。注意左括号和右括号都不会加入后缀表达式；

        (左括号和右括号进栈只是起标记作用) 

     3. 遇到**运算符**：依次弹出栈中**优先级高于或等于当前运算符**的所有运算符，并加入后缀表达式，**若碰到'('或栈空则停止，然后再把当前运算符入栈。**

     4. 按上述步骤处理完所有字符后，将栈中剩余运算符依次弹出  

   - 第二步：**利用栈计算后缀表达式**(v9 00:20:31)

     从左到右扫描表达式：

     1. 遇到操作数：压入堆栈
     2. 遇到运算符：弹出栈顶两个元素，并用该运算符对其进行计算，注意**先弹出栈的元素是右操作数**，然后再将此结果压入堆栈
     3. 重复此过程直至表达式最后端，最后的结果即为所求

#### C++动态内存

1.  引用和指针的关系

   &：takes an object and returns the object’s address

   \*：takes a **pointer object** and returns the object that it points to

2. 指针定义、new、delete

   - `int *r = new int;`

     **C++为程序在堆上申请了一块内存，用来存一个int型变量。指针r指向这个int型变量**

   - 在delete后还需要将指针置为NULL

     因为**在delete(删除)一个指针之后，编译器只会释放该指针所指向的内存空间，而不会删除这个指针本身。**

3. 栈内存与堆内存

   `int n;	//临时分配是栈内存，使用完毕自动释放内存`
   `int* p = new int; //动态分配是堆内存, 使用完毕需要手动释放内存`

4. 数组与指针

   - 声明动态数组：`array = new int[array_size];` 

   - `array`即数组首地址

     `array+i`即数组中第i个元素地址

     `*(array+i)`即第i个元素的具体值，等价于`array[i]` 

   - 释放数组空间：`delete [] a`

5. C++多重指针

   ```C++
   char ch=‘b’;
   char *p1=&ch;
   char **p2=&p1;
   ```

   `char *p`是指向char类型对象的指针
   `char **p`是指向char *类型对象的指针(**即指向指针的指针**)

6. 总结：**声明了指针，还需要声明这个指针指向的对象(重要理解，对链表代码的理解很有帮助)**

#### 链表

1. 基本结构：数据域(data)和指针域(next) 

2. 教材中每个链表开头都有一个**单独的head指针**，这和王道中带**头结点**的链表有所不同

   - **教材中建表是基于`Node *head = NULL;(初始化为空指针)`**

   - **王道中头结点L是一个单独的结构体**，数据域不存储信息，所以要进行遍历链表这种操作，代码为`Node *p = L->next;`

3. **链表的基本操作**

   1. 创建空链表
   2. 插入一个元素：默认为后插
   3. 删除一个元素
   4. 访问链表的元素
   5. 查找元素

4. 链表结点结构体(C++ struct)

   注意**C++结构体构造函数**的使用

   注：我之前的循环链表代码没有使用结构体构造函数，这里写代码熟悉一下。

   ```C
   struct Node {
       int entry;//具体数据
       Node *next;//next指针
       Node( );//结构体构造函数
       Node(int item, Node *p = NULL);
   };
   
   Node::Node( )//无参构造函数(创建结构体成员时这个构造函数必会执行)
   {
       next = NULL;
   }
   
   Node::Node(int item, Node *p)//含参构造函数
   {
       entry = item;
       next = p;
   }
   
   int main( )
   {
       Node first_node(666);//含参构造函数的使用
       Node *x = &first_node;
       Node seconde_node(888,x);
       cout << seconde_node.next->next;//这里是很重要的一点,second_node是Node，而不是Node*，访问内部变量必须用.,即只有当本体为指针类型时,才能对应于用->
       return 0;
   }
   ```

5. **建立链表**

   - 教材中建表是基于**Node *head = NULL**,没有王道中的”头结点“一说
   - 同样可以有头插法和尾插法两种建表思路：
     1. 头插法：一直在head指向结点的下一位置进行插入
     2. 尾插法(建议使用，因为这样**链表内容才和输入顺序一致**)：
   
6. **双向链表**

7. **循环链表** 

   **用循环链表解决约瑟夫问题**

8. 循环双链表

### W4 递归、DFS、BFS

#### 斐波那契数列

递归&非递归实现

#### 汉诺塔

- 最重要的理解：为什么函数写成这样子就能详细地列出具体的移动步骤？

- 对于A,B,C三个柱子，要把A柱上的n个盘子按原顺序移至C柱，**必须先把A柱上的n-1个盘子移至B柱**，再把最大的盘子从A移至C，再将B的n-1个盘子全部移到C。

- 汉诺塔问题需要特别注意参数的顺序，这也是递归的精髓，所有步骤在形式上都是相同的，因此递归最重要的就是**根据实际问题设计出这相同的形式**，并**给出相同形式下参数的具体变化**。

- > 参考 https://www.zhihu.com/question/24385418

#### DFS(深度优先遍历)



#### BFS(广度优先遍历)

#### 八皇后问题

- > 参考 https://blog.csdn.net/qq_41620518/article/details/81180081





### W9 树基本概念、二叉树、二分查找树

#### 概要

1. 树的基本概念
2. (完全二叉)树的数组表示
3. 树的三种遍历算法
4. 普通二叉树的构建
5. 二叉查找树(插入、查找、删除）

#### 理论内容

(基于王道&已有笔记进行补充)

1. 两种特殊的二叉树

   1. 满二叉树

   2. **完全二叉树**

      - **结点数为n的完全二叉树的深度(高度)**

        (注意王道中序数从1起，**ppt中从0起**)

        设高度为h，则有两种计算方法，由满二叉树结点数与树高的关系，结合临界高度进行推导：

        序数从1起：

        ①$h=\left\lfloor\log _{2} n\right\rfloor+1$

        ②$h=\left\lceil\log _{2}(n+1)\right\rceil$

        序数从0起：

        ①$h=\left\lfloor\log _{2} n\right\rfloor$

        ②$h=\left\lceil\log _{2}(n+1)\right\rceil-1$

      - **完全二叉树孩子序号和父亲的关系(0起)**

        结点i的左子结点是2i+1，右子结点是2i+2，父节点是(i-1)/2

        代码中的/都是向下取整

      - 序号为奇数是左孩子，为偶数是右孩子

2. 二叉树的两种表示方法

   1. 数组表示

   2. **链式表示**

      结点结构体的定义/结点的实现

3. **二叉树的遍历**

   - 前序遍历、中序遍历、后序遍历的“前”、“中“、”后“都是访问根结点的顺序
   - 掌握三种遍历的递归代码(基础)

#### 代码题(思路or伪代码)

1. 求完全二叉树的高度

   不涉及数据结构，实现算法即可

2. 新插入一个结点至完全二叉树末尾(链式表示情况下)

   - 获取当前插入位置的序号，因为根据序号才能得到与双亲节点的关系
   - 计算该插入结点是左孩子还是右孩子，将信息入栈保存(**使用栈数据结构**)
   - 若双亲节点不是根结点，则继续往上回溯，并把结点信息(包括是左孩子还是右孩子)入栈
   - 直至根结点，将信息出栈，即得到根结点到被插入结点的一条完整插入路径

   \***这道题是由于"链表不能随机存取"，所以必须回溯至根结点**

3. 求普通二叉树的高度(递归求解&伪代码) 较易，略













